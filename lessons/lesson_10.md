# Занятие 10

## Теоретическая часть

### Оглавление
1. Аутентификация  
1.1 Основные термины  
1.2 Аутентификация при помощи passport.js  
1.3 Сессии  
2. Авторизация  
2.1 Основные термины  
2.2 Oauth2  
2.3 Авторизация при помощи passport.js
3. Безопасность  
3.1 Виды уязвимостей  
3.2 Helmet.js  
4. Домашнее задание  
4.1 Теория  
4.2 Практическое задание по работе с Json Web Token  
5. Источники  

### 1. Аутентификация
#### 1.1 Основные термины
**Аутентификация** - это проверка соответствия субъекта и того, за кого он пытается себя выдать, с помощью некой уникальной информации (отпечатки пальцев, цвет радужки, голос и тд.), в простейшем случае - с помощью имени входа и пароля.

#### 1.2 Аутентификация при помощи passport.js
**Passport** — это middleware для проверки подлинности, которую мы собираемся использовать для управления сессиями.

Наша цель — реализовать в нашем приложении следующий процесс аутентификации:

1. Пользователь вводит имя и пароль
2. Приложение проверяет, являются ли они корректными
3. Если имя и пароль корректны, приложение отправляет заголовок Set-Cookie, который будет использоваться для аутентификации дальнейших страниц
4. Когда пользователь посещает страницы в том же домене, ранее установленный cookie будет добавлен ко всем запросам
5. Аутентификация на закрытых страницах происходит с помощью этого файла cookie

Чтобы настроить такую стратегию аутентификации, выполните следующие два действия:

1. Настройте Express
```javascript
const express = require('express')
const passport = require('passport')
const session = require('express-session')
const mongoStore = require('connect-mongodb');
const app = express()
// подробнее о сессиях в главе 1.3
app.use(session({
    secret: 'topsecret',
    maxAge: new Date(Date.now() + 3600000),
    store: new mongoStore({ db: 'myDb' })
}))
app.use(passport.initialize())
app.use(passport.session())
```

2. Настройте Passport
**Passport** — отличный пример библиотеки, использующей плагины. В этом уроке мы добавляем модуль passport-local, который добавляет простую локальную стратегию аутентификации с использованием имён пользователей и паролей.

```javascript
const passport = require('passport')
const LocalStrategy = require('passport-local').Strategy
const user = {
    username: 'test-user',
    password: 'my-password',
    id: 1
}
passport.use(new LocalStrategy(
    function(username, password, done) {
        findUser(username, function (err, user) {
            if (err) {
                return done(err)
            }
            if (!user) {
                return done(null, false)
            }
            if (password !== user.password ) {
                return done(null, false)
            }
            return done(null, user)
        })
    }
))
```

### 1.3 Сессии
Алгоритм работы сессий прост:
1. Отправка специальной куки, которая содержит идентификатор сессии. Имя этой куки задается на этапе старта приложения
2. Сохранение и извлечение данных. В качестве места хранения может в памяти, куках и в базе данных. (в нашем случае mongodb)
3. Завершение сессии

Работа с сессиями в Express.js с использвованием express-session:
```javascript
/*1*/app.use(session({
/*2*/    secret: 'topsecret',
/*3*/    maxAge: new Date(Date.now() + 3600000),
/*4*/    store: new mongoStore({ db: 'myDb' })
    }))
```
1. Устанавливаем middleware express-session
2. В качестве первого аргумента передаем salt
3. В качестве второго аргумента передаем продолжительность сессии
4. Указываем где хранить сесии (если не указать будет храниться в памяти)

Так же желательно указать
```
httpOnly: true
```
Чтобы сессионная кука была доступна только с сервера

Далее с сессиями можно работать из объекта req

```javascript
req.session.destroy(err => {
    console.error(err)
})
```
Подробнее на https://github.com/expressjs/session

### 2. Авторизация
#### 2.1 Основные термины
**Авторизация** - это проверка и определение полномочий на выполнение некоторых действий в соответствии с ранее выполненной аутентификацией.

**OAuth 2.0** — протокол авторизации, позволяющий выдать одному сервису (приложению) права на доступ к ресурсам пользователя на другом сервисе. Протокол избавляет от необходимости доверять приложению логин и пароль, а также позволяет выдавать ограниченный набор прав, а не все сразу.

**Токены** предоставляют собой средство авторизации для каждого запроса от клиента к серверу. Токены(и соотвественно сигнатура токена) генерируются на сервере основываясь на секретном ключе(который хранится на сервере) и payload'e. Токен в итоге хранится на клиенте и используется при необходимости авторизации како-го либо запроса. Такое решение отлично подходит при разработке SPA.

**access token** — некий ключ (обычно просто набор символов), предъявление которого является пропуском к защищенным ресурсам.

**refresh token** - выдается сервером по результам успешной аутентификации и используется для получения нового access token'a и обновления refresh token'a
W
#### 2.2 Oauth2
Общая схема работы приложения, использующего OAuth, такова:
1. получение авторизации
2. обращение к защищенным ресурсам

Результатом авторизации является **access token**

В протоколе описано несколько вариантов авторизации, подходящих для различных ситуаций:
1. авторизация для приложений, имеющих серверную часть (чаще всего, это сайты и веб-приложения)
2. авторизация для полностью клиентских приложений (мобильные и desktop-приложения)
3. авторизация по логину и паролю
4. восстановление предыдущей авторизации

Далее рассмотрим схему авторизации для приложений, имеющих серверную часть

![схема авторизации](https://habrastorage.org/storage/0309cc52/d3bd6b1e/b44ab1f6/64e01804.png)

1. Редирект на страницу авторизации
2. На странице авторизации у пользователя запрашивается подтверждение выдачи прав
3. В случае согласия пользователя, браузер редиректится на URL, указанный при открытии страницы авторизации, с добавлением в GET-параметры специального ключа — authorization code
4. Сервер приложения выполняет POST-запрос с полученным authorization code в качестве параметра. В результате этого запроса возвращается access token

#### 2.3 Авторизация при помощи passport.js

Чтобы добавить защищенные разделы на сайт, мы используем шаблон middleware Express. Для этого сначала создадим middleware для аутентификации:

```javascript
const passport = require('passport')
app.get('/profile', passport.authenticationMiddleware(), renderProfile)
```

Она имеет только одну задачу — если пользователь аутентифицирован (имеет правильные cookie-файлы), она просто вызывает следующую middleware. В противном случае пользователь перенаправляется на страницу, где он может войти в систему.

Использование этой middleware также просто, как добавление любой другой middleware в определение роута.

### 3. Безопасность
#### 3.1 Виды уязвимостей
- **contentSecurityPolicy** задает заголовок Content-Security-Policy для предотвращения атак межсайтового скриптинга и прочих межсайтовых вмешательств.
- **crossdomain** for handling Adobe products’ crossdomain requests
- **dnsPrefetchControl** controls browser DNS prefetching
- **expectCt** for handling Certificate Transparency
- **frameguard** задает заголовок X-Frame-Options для защиты от кликджекинга.
- **hidePoweredBy** удаляет заголовок X-Powered-By.
- **hpkp** добавляет заголовки Public Key Pinning для предотвращения атак посредника (атак “человек посередине”) с поддельными сертификатами.
- **hsts** задает заголовок Strict-Transport-Security, принудительно активирующий защиту соединений с сервером (по протоколу HTTP с использованием SSL/TLS).
- **ieNoOpen** задает заголовок X-Download-Options для IE8+.
- **noCache** задает заголовок Cache-Control и заголовки Pragma для отключения кеширования на стороне клиента.
- **noSniff** задает заголовок X-Content-Type-Options для защиты браузеров от прослушивания (сниффинга) MIME ответов с отличным от объявленного типом содержимого (content-type).
- **referrerPolicy** скрывает заголовок Referer
- **xssFilter** задает заголовок X-XSS-Protection для активации фильтра XSS (фильтра межсайтового скриптинга) в большинстве современных веб-браузеров.
### 3.2 Helmet.js

Данная библиотека предоставляет защиту от перечисленных выше уязвимостей

Использовать ее просто:
```javascript
const express = require('express')
const helmet = require('helmet')

const app = express()

app.use(helmet())
```

Но по умолчанию включены не все, остальные можно включить таким образом:

```javascript
app.use(helmet.noCache())
app.use(helmet.frameguard())
```
https://github.com/helmetjs/helmet

### JWT
**JSON Web Token (JWT)** — содержит три блока, разделенных точками: заголовок(header), набор полей (payload) и сигнатуру. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие). Сигнатура может генерироваться при помощи и симметричных алгоритмов шифрования, и асимметричных. Кроме того, существует отдельный стандарт, отписывающий формат зашифрованного JWT-токена.

Пример подписанного JWT токена (после декодирования 1 и 2 блоков):
```
{ «alg»: «HS256», «typ»: «JWT» }.{ «iss»: «auth.myservice.com», «aud»: «myservice.com», «exp»: «1435937883», «userName»: «John Smith», «userRole»: «Admin» }.S9Zs/8/uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY
```
#### Схема создания/использования токенов
1. Пользователь логинится в приложении, передавая логин/пароль на сервер
2. Сервер проверят подлинность логина/пароля, в случае удачи генерирует и отправляет клиенту два токена(access, refresh) и время смерти access token'а (expires_in поле, в unix timestamp). Также в payload refresh token'a добавляется user_id
    ```
    "accessToken": "...",
    "refreshToken": "...",
    "expires_in": 1502305985425
    ```
3. Клиент сохраняет токены и время смерти access token'а, используя access token для последующей авторизации запросов
4. Перед каждым запросом клиент предварительно проверяет время жизни access token'а (из expires_in)и если оно истекло использует refresh token чтобы обновить ОБА токена и продолжает использовать новый access token

#### Схема рефреша токенов
1. Клиент проверяет перед запросом не истекло ли время жизни access token'на  
2. Если истекло клиент отправляет на auth/refresh-token URL refresh token  
3. Сервер берет user_id из payload'a refresh token'a по нему ищет в БД запись данного юзера и достает из него refresh token  
4. Сравнивает refresh token клиента с refresh token'ом найденным в БД  
5. Проверяет валидность и срок действия refresh token'а  
6. В случае успеха сервер:  
6.1 Создает и перезаписывает refresh token в БД  
6.2 Создает новый access token  
6.3 Отправляет оба токена и новый expires_in access token'а клиенту  
7. Клиент повторяет запрос к API c новым access token'ом  

Пример:
https://github.com/zmts/supra-api-nodejs/tree/master/actions/auth  


## Практическая часть

### Задание 1


## Homework

### Задание 1
Добавить в приложение авторизацию по JWT


## Источники
- https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc
- https://habr.com/post/145988/
- https://habr.com/company/mailru/blog/115163/
- https://habr.com/post/193458/#p5
- https://medium.com/devschacht/node-hero-chapter-8-27b74c33a5ce
- http://expressjs.com/ru/advanced/best-practice-security.html